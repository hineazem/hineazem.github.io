window.ConfettiGenerator = function (options) {
    function getRandomValue(max, integer) {
        max = max || 1;
        const value = Math.random() * max;
        return integer ? Math.floor(value) : value;
    }

    function createConfettiPiece() {
        return {
            prop: config.props[getRandomValue(config.props.length, true)],
            x: getRandomValue(config.width),
            y: getRandomValue(config.height),
            radius: getRandomValue(4) + 1,
            line: Math.floor(getRandomValue(65) - 30),
            angles: [getRandomValue(10, true) + 2, getRandomValue(10, true) + 2, getRandomValue(10, true) + 2, getRandomValue(10, true) + 2],
            color: config.colors[getRandomValue(config.colors.length, true)],
            rotation: getRandomValue(360, true) * Math.PI / 180,
            speed: getRandomValue(config.clock / 7) + config.clock / 30
        };
    }

    function drawConfettiPiece(piece) {
        const alpha = piece.radius <= 3 ? 0.4 : 0.8;
        ctx.fillStyle = ctx.strokeStyle = `rgba(${piece.color}, ${alpha})`;
        ctx.beginPath();

        switch (piece.prop) {
            case 'circle':
                ctx.moveTo(piece.x, piece.y);
                ctx.arc(piece.x, piece.y, piece.radius * config.size, 0, 2 * Math.PI, false);
                ctx.fill();
                break;
            case 'triangle':
                ctx.moveTo(piece.x, piece.y);
                ctx.lineTo(piece.x + piece.angles[0] * config.size, piece.y + piece.angles[1] * config.size);
                ctx.lineTo(piece.x + piece.angles[2] * config.size, piece.y + piece.angles[3] * config.size);
                ctx.closePath();
                ctx.fill();
                break;
            case 'line':
                ctx.moveTo(piece.x, piece.y);
                ctx.lineTo(piece.x + piece.line * config.size, piece.y + 5 * piece.radius);
                ctx.lineWidth = 2 * config.size;
                ctx.stroke();
                break;
            case 'square':
                ctx.save();
                ctx.translate(piece.x + 15, piece.y + 5);
                ctx.rotate(piece.rotation);
                ctx.fillRect(-15 * config.size, -5 * config.size, 15 * config.size, 5 * config.size);
                ctx.restore();
                break;
        }
    }

    const config = {
        target: 'confetti-holder',
        max: 80,
        size: 1,
        animate: true,
        props: ['circle', 'square', 'triangle', 'line'],
        colors: [[165, 104, 246], [230, 61, 135], [0, 199, 228], [253, 214, 126]],
        clock: 25,
        interval: null,
        width: window.innerWidth,
        height: window.innerHeight
    };

    if (options) {
        if (options.target) config.target = options.target;
        if (options.max) config.max = options.max;
        if (options.size) config.size = options.size;
        if (options.animate !== undefined) config.animate = options.animate;
        if (options.props) config.props = options.props;
        if (options.colors) config.colors = options.colors;
        if (options.clock) config.clock = options.clock;
        if (options.width) config.width = options.width;
        if (options.height) config.height = options.height;
    }

    const canvas = document.getElementById(config.target);
    const ctx = canvas.getContext('2d');
    const confettiPieces = [];

    return {
        render: function () {
            function animate() {
                ctx.clearRect(0, 0, config.width, config.height);
                confettiPieces.forEach(piece => drawConfettiPiece(piece));
                updateConfetti();
            }

            function updateConfetti() {
                for (let i = 0; i < config.max; i++) {
                    const piece = confettiPieces[i];
                    if (config.animate) piece.y += piece.speed;
                    if (piece.y > config.height) {
                        confettiPieces[i] = piece;
                        confettiPieces[i].x = getRandomValue(config.width, true);
                        confettiPieces[i].y = -10;
                    }
                }
            }

            canvas.width = config.width;
            canvas.height = config.height;
            confettiPieces.length = 0;
            for (let i = 0; i < config.max; i++) {
                confettiPieces.push(createConfettiPiece());
            }

            if (config.animate) {
                config.interval = setInterval(animate, 20);
            } else {
                animate();
            }
        },
        clear: function () {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const width = canvas.width;
            canvas.width = 1;
            canvas.width = width;
            clearInterval(config.interval);
        }
    };
};
